{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>KOR-ee, from the greek \u039a\u03cc\u03c1\u03b7, the queen of the underworld, daughter of Zeus and Demeter. Kore is a numerical tool to study the core flow within rapidly rotating planets or other rotating fluids contained within near-spherical boundaries. The current version solves the linear Navier-Stokes and induction equations for a viscous, incompressible and conductive fluid with an externally imposed magnetic field, and enclosed within a rotating spherical shell.</p> <p>Kore assumes all dynamical variables to oscillate in a harmonic fashion. The oscillation frequency can be imposed externally, as is the case when doing forced motion studies (e.g. tidal forcing), or it can be obtained as part of the solution to an eigenvalue problem. In Kore's current implementation, the eigenmodes are the inertial modes of the rotating fluid. Inertial modes are the global modes of a rotating flow in which the Coriolis force participates prominently in the restoring force balance.</p> <p>Kore's distinctive feature is the use of a very efficient spectral method employing Gegenbauer (also known as ultraspherical) polynomials as a basis in the radial direction. This approach leads to sparse matrices representing the differential equations, as opposed to dense matrices, as in traditional Chebyshev colocation methods. Sparse matrices have smaller memory-footprint and are more suitable for systematic core flow studies at extremely low viscosities (or small Ekman numbers).</p> <p>Kore is free for everyone to use, with no restrictions. Too often in the scientific literature the numerical methods used are presented with enough detail to guarantee reproducibility, but only in principle. Without access to the actual implementation of those methods, which would require a significant amount of work and time to develop, readers are left effectively without the possibility to reproduce or verify the results presented. This leads to very slow scientific progress. We share our code to avoid this.</p> <p>If this code is useful for your research, we invite you to cite the relevant papers (coming soon) and hope that you can also contribute to the project.</p>"},{"location":"1installation/","title":"Installation Notes","text":"<p>To run <code>kore</code> we need the PETSc/SLEPc packages and their python bindings petsc4py/slepc4py. PETSc needs to be compiled with support for complex scalars. MUMPS and SuperLU_dist are external packages that need to be installed together with PETSc.</p> <p>If you are interested in problems that involve very large matrices, for instance when considering extremely small viscosities, we recommend doing so with a machine with at least 128 GB of memory. The number of processing cores is not critical, eight are fine, 24 are plenty. Small to moderate size matrices can be solved using a laptop, depending on available memory. </p> <p>From our experience the PETSc version that has allowed us to solve the largest problems is version 3.9.4. That version requires python 3.7, however. Newer PETSc versions seem to have much larger memory footprint, although they can still handle medium size problems without issues. So, our advice is to install PETSc version 3.9.3 if the problem involves very large matrices, otherwise it is better to stick to the most recent PETSc release.</p>"},{"location":"1installation/#installing-petscslepc-on-macos","title":"Installing PETSc/SLEPc on MacOS","text":"<p>It is convenient to have a dedicated python environment to use with <code>kore</code>. It is quite simple to create and activate it:</p> <pre><code>python3 -m venv kore_env\nsource kore_env/bin/activate\n</code></pre> <p>Then we need to install scipy and cython in that environment: <pre><code>pip3 install scipy cython\n</code></pre></p> <p>Now we download the latest PETSc/SLEPc releases using <code>git</code> <pre><code>git clone -b release https://gitlab.com/petsc/petsc.git petsc\ngit clone -b release https://gitlab.com/slepc/slepc slepc\n</code></pre></p> <p>We go now into the newly created <code>petsc</code> folder and configure PETSc: <pre><code>cd petsc\n./configure --with-petsc4py --download-mpi4py --download-mpich --with-scalar-type=complex --download-mumps --download-parmetis --download-metis --download-scalapack --download-fblaslapack --with-debugging=0 --download-superlu_dist --download-ptscotch CXXOPTFLAGS='-O3 -march=native' FOPTFLAGS='-O3 -march=native' COPTFLAGS='-O3 -march=native' --download-bison\n</code></pre> Then we build PETSc: <pre><code>make PETSC_DIR=/path/to/petsc PETSC_ARCH=arch-darwin-c-opt all\n</code></pre> where you must replace <code>/path/to/petsc</code> with the actual path for your case. Before checking that everything works we must tell python where to find <code>petsc4py</code> and <code>mpi4py</code>, which were compiled along in the step above: <pre><code>export PYTHONPATH=/path/to/petsc/arch-darwin-c-opt/lib\n</code></pre> where again we must replace <code>/path/to/petsc</code> with the actual path. Now we test the installation: <pre><code>make PETSC_DIR=/path/to/petsc PETSC_ARCH=arch-darwin-c-opt check\n</code></pre> If no errors appear then you can proceed to install SLEPc. If an error is reported due to python not being able to find PETSc (even though we just updated the <code>PYTHONPATH</code>), but the other MPI tests were successful, then don't worry, it is safe to ignore the error.</p> <p>We need to setup some environment variables before installing SLEPc: <pre><code>export PETSC_DIR=/path/to/petsc\nexport PETSC_ARCH=arch-darwin-c-opt\nexport SLEPC_DIR=/path/to/slepc\n</code></pre></p> <p>Now go to the slepc folder, configure and build SLEPc: <pre><code>cd $SLEPC_DIR\n./configure\nmake\nmake check\n</code></pre> The last step is to install slepc4py, which is distributed along with SLEPc: <pre><code>cd $SLEPC_DIR/src/binding/slepc4py\npython3 setup.py build\npython3 setup.py install\n</code></pre> Almost there now. We need to update the <code>PATH</code> environment variable so that we can use the MPI library provided by PETSc instead of the one provided by your system, if any: <pre><code>export PATH=$PETSC_DIR/$PETSC_ARCH/bin:$PATH\n</code></pre></p> <p>It is a good idea to keep the necessary commands for initialization in a separate file. It should contain the following lines: <pre><code>source /path/to/kore_env/bin/activate\nexport PETSC_DIR=/path/to/petsc\nexport PETSC_ARCH=arch-darwin-c-opt\nexport SLEPC_DIR=/path/to/slepc\nexport PYTHONPATH=$PETSC_DIR/$PETSC_ARCH/lib\nexport PATH=$PETSC_DIR/$PETSC_ARCH/bin:$PATH\n</code></pre> We can write that to a file named e.g. <code>kore_env.sh</code> in your home directory, so every time you need to prepare to run <code>kore</code> we do first: <pre><code>source $HOME/kore_env.sh\n</code></pre></p>"},{"location":"1installation/#installing-on-linux","title":"Installing on Linux","text":"<p>Coming soon</p>"},{"location":"1installation/#shtns","title":"SHTns","text":"<p>Coming soon</p>"},{"location":"2definition/","title":"Physical definition","text":"<p>Kore solves the flow inside near-spherical rotating bodies in a wide range of scenarios pertaining to the context of planetary liquid cores. The basic physical problem considers the fluid body rotating to a large extent as a rigid body with angular velocity \\(\\mathbf\\Omega\\), and small velocity perturbations \\(\\mathbf u\\) exist over the background field \\(\\mathbf\\Omega\\times\\mathbf r\\). Kore assumes this perturbation to be oscillatory and very small compared to the maximum value of \\(\\mathbf\\Omega\\times\\mathbf r\\) attained in the volume's domain. In the most basic of scenarios, Kore solves the linearized and incompressible Navier-Stokes momentum equation and finds \\(\\mathbf u\\). In the absence of external forcings, the equation can be solved as an eigenvalue problem, for which the frequencies \\(\\omega\\) of oscillation of \\(\\mathbf u\\) are obtained together with their respective eigenmodes - characteristic velocity profiles, see Numerical Scheme for more information.</p> <p>Below, the basic equations defining each problem will be provided, together with their respective boundary conditions. All are given in their homogeneous version - i.e. for the resolution of the egienvalue problem. Forcings will be covered in Numerical Scheme.</p>"},{"location":"2definition/#momentum-equation","title":"Momentum equation","text":"<p>The most basic of problems poses the Navier-Stokes momentum equation. Under the assumption of oscillatory velocity perturbations, one can write \\(\\mathbf u \\sim e^{\\lambda t}\\), where \\(\\lambda\\in\\mathbb C\\) encompasses both the damped and oscillatory characteristics of the motion. Time derivatives of \\(\\mathbf u\\) then turn into products by \\(\\lambda\\). With this notation, the momentum equation in a reference frame rotating with the container/planet at angular speed \\(\\mathbf\\Omega\\) - the mantle frame - is written as:</p> \\[ \\lambda\\rho\\mathbf u + 2\\rho\\mathbf\\Omega\\times\\mathbf u = -\\nabla p + \\rho\\mathbf g + \\rho\\nu\\nabla^2\\mathbf u \\] <p>Here, \\(\\rho\\) and \\(\\nu &gt; 0\\) are the fluid's density and kinematic viscosity respectively, while \\(p\\) is the reduced pressure - sum of physical pressure and centrifugal potential - and \\(\\mathbf g\\) is the acceleration of gravity. Note that, in this equation, \\(\\mathbf u\\) is a complex vector that does not depend on time.</p> <p>In the general case, the momentum equation is imposed in a (near-)spherical shell of inner radius \\(r_{icb}\\) and outer radius \\(r_{cmb}\\) - the inner core boundary (ICB) and the core mantle boundary (CMB). This scenario then requires the no-penetration and no-slip boundary condition at both surfaces. Under the assumption that the inner core and mantle rotate at the same angular speed \\(\\mathbf\\Omega\\), this boundary condition is trivially written as \\(\\mathbf u_{icb} = \\mathbf u_{cmb} = \\mathbf 0\\). At the moment, Kore cannot handle differential rotation between the inner core and mantle. Alternatively, Kore allows to set stress-free boundary conditions, so that the radial derivative of \\(\\mathbf u\\) vanishes at the boundaries. The boundary conditions at the ICB and the CMB need not be the same. TODO: La stress-free boundary condition no es compatible con un flujo m\u00ednimamente viscoso, no?</p> <p>If the physical model lacks an inner core (\\(r_{icb} = 0\\)), the inviscid momentum equation can be considered, i.e. \\(\\nu = 0\\). This problem only has one boundary, namely the CBM, where the only feasible boundary condition is now the stress-free BC. The second boundary condition required to complete the problem is that of regularity at the origin.</p> <p>Currently, Kore can only work with constantly rotating bodies, so that one can write \\(\\mathbf\\Omega = \\Omega\\hat{\\mathbf z}\\). Here, \\(\\Omega\\) is just the angular rate of rotation while \\(\\hat{\\mathbf z}\\) is the unit vector along the body's rotation axis.</p>"},{"location":"2definition/#induction-equation","title":"Induction equation","text":"<p>On Earth, the liquid core is conductive iron and its motion produces a magnetic field. In the presence of an imposed background magnetic field \\(\\mathbf B_o\\), the small oscilations \\(\\mathbf u\\) will induce a similarly small and oscillatiory magnetic field perturbation \\(\\mathbf b \\sim e^{\\lambda t}\\), with magnitude much smaller than \\(\\mathbf B_o\\). The evolution of this magnetic perturbation is given by the electromagnetic induction equation as (see Triana et al. 2021a):</p> \\[ \\lambda\\mathbf b = \\nabla\\times(\\mathbf u\\times\\mathbf B_o) + \\eta\\nabla^2\\mathbf b \\] <p>Here, \\(\\eta\\) is the fluid's magnetic diffusivity, while \\(\\mathbf b\\) is again a complex vector with a purely spatial dependance.</p> <p>The magnetic boundary conditions are many. TODO: I'm not sure how many there are, and I don't really understand them all...</p> <p>In the presence of magnetic fields, the conductive iron will be subject to an electromagnetic force \\(\\mathbf F_{em}\\) (the Lorentz force), which should be added to the right hand side of the momentum equation. This force is written as:</p> \\[ \\mathbf F_{em} = \\frac{1}{\\mu_o}(\\nabla\\times\\mathbf b)\\times\\mathbf B_o \\] <p>Here, \\(\\mu_o\\) is the magnetic permeability. The momentum equation - or its boundary conditions - are not affected any further.</p>"},{"location":"2definition/#heat-equation","title":"Heat equation","text":"<p>Heat distribution becomes important when either the eigenfrequencies or the forcings share the same time scales as, most notably, heat convection. Kore can solve the linearized heat equation:</p> \\[ \\lambda\\theta = -\\mathbf u \\cdot \\nabla T_o + \\kappa\\nabla^2\\theta \\] <p>Here, \\(\\theta\\) is a small and oscillatory temperature deviation from a background isentropic temperature profile \\(T_o\\), which is assumed by Kore to be dependent only on \\(r\\). The resulting adiabatic temperature gradient then reduces to a radial derivative, while its dot product with \\(\\mathbf u\\) will only involve the radial velocity. Kore implements three different possibilities for this gradient. On the other hand, \\(\\kappa\\) is the thermal diffusivity of the medium.</p> <p>Kore implements the constant-temperature and constant-flux boundary conditions - a prescribed value of \\(\\theta\\) or its derivative, respectively. Either can be chosen at the ICB or the CMB, but note that imposing a constant heat flux at both boundaries results in an ill-posed problem.</p> <p>Mathematically speaking, this equation could be solved independently. Physically, temperature changes will trigger density changes in the fluid. In Kore, this coupling is implemented through the Boussinesq approximation, by which the only real impact of a density change is in the buoyancy term \\(\\rho\\mathbf g\\) of the momentum equation. In the Boussinesq approximation, this term is written as:</p> \\[ \\rho\\mathbf g \\longrightarrow \\rho'\\mathbf g = -\\rho\\alpha\\theta\\mathbf g \\] <p>Here, \\(\\rho' = -\\rho\\alpha\\theta\\) is the density perturbation caused by the respective temperature perturbation \\(\\theta\\), which is proportional to \\(\\rho\\) itself and the fluid's expansion coefficient \\(\\alpha\\).</p>"},{"location":"2definition/#compositional-equation","title":"Compositional equation","text":"<p>TODO: Coming soon...</p>"},{"location":"3nondim/","title":"Non-dimensionalization","text":"<p>In solving the relevant equations, Kore uses dimensionaless variables. A non-dimensionalization procedure is always possible thanks to the Buckingham-\\(\\pi\\) theorem. For this, the following will be used as units of length, mass, time, temperature respectively: \\(L\\), \\(\\tau\\), \\(\\rho L^3\\), \\(\\theta^*\\). On the other hand, several vectors can be written as the product of a typical value of their magnitude times a non-dimensional vector to provide direction. Thus, one can write \\(\\mathbf g \\rightarrow g^*\\mathbf g\\), \\(\\mathbf B_o \\rightarrow B^*\\mathbf B_o\\) and \\(\\mathbf b \\rightarrow B^*\\mathbf b\\), where the vectors on the left hand sides are dimensional and those on the right hand side are non-dimensional, while the starred quantities are their characteristic values and provide the units. Similarly one can also write \\(\\mathbf\\Omega = \\Omega\\hat{\\mathbf z}\\) (see Physical Definition). Finally, and because it represents an angular frequency, the non-dimensionalization \\(\\lambda \\rightarrow \\lambda/\\tau\\) follows.</p> <p>After dividing the momentum equation by \\(\\rho\\), applying all appropriate non-dimensionalizations to all equations and cancelling some common terms, the non-dimensional equations read:</p> \\[ \\displaylines{ \\lambda\\mathbf u + 2(\\Omega\\tau)\\hat{\\mathbf z}\\times\\mathbf u = -\\nabla p-(\\Omega\\tau)^2\\frac{\\alpha g^*\\theta^*}{\\Omega^2L}\\theta\\mathbf g + (\\Omega\\tau)\\frac{\\nu}{\\Omega L^2}\\nabla^2\\mathbf u + \\frac{(\\Omega\\tau)^2}{\\rho\\mu_o}\\bigg(\\frac{B^*}{\\Omega L}\\bigg)^2(\\nabla\\times\\mathbf b)\\times\\mathbf B_o \\\\ \\lambda\\mathbf b = \\nabla\\times(\\mathbf u\\times\\mathbf B_o) + (\\Omega\\tau)\\frac{\\eta}{\\Omega L^2}\\nabla^2\\mathbf b \\\\ \\lambda\\theta = -\\mathbf u\\cdot\\nabla T_o + (\\Omega\\tau)\\frac{\\kappa}{\\Omega L^2}\\nabla^2\\theta } \\] <p>Here, all vector quantites, derivatives, dependent variables as well as the background temperature profile \\(T_o\\) and the eigenfrequency \\(\\lambda\\) are non-dimensional. These equations can be simpified by the introduction of several non-dimensional numbers:</p> \\[ \\displaylines{ \\text{Ekmann number:}\\ \\ E = \\frac{\\nu}{\\Omega L^2} \\\\ \\text{Lenhert number:}\\ \\ Le = \\frac{B^*}{\\Omega L\\sqrt{\\rho\\mu_o}} \\\\ \\text{Rayleigh number:}\\ \\ Ra = \\frac{\\alpha g^*\\theta^* L^3}{\\nu\\kappa} \\\\ \\text{Prandtl number:}\\ \\ Pr = \\frac{\\nu}{\\kappa} \\\\ \\text{Magnetic Ekmann number:}\\ \\ E_\\eta = \\frac{\\eta}{\\Omega L^2} } \\] <p>Using these quantities, the equations can be rewritten as:</p> \\[ \\displaylines{ \\lambda\\mathbf u + 2(\\Omega\\tau)\\hat{\\mathbf z}\\times\\mathbf u = -\\nabla p-(\\Omega\\tau E)^2\\frac{Ra}{Pr}\\theta\\mathbf g + \\Omega\\tau E\\nabla^2\\mathbf u + (\\Omega\\tau Le)^2(\\nabla\\times\\mathbf b)\\times\\mathbf B_o \\\\ \\lambda\\mathbf b = \\nabla\\times(\\mathbf u\\times\\mathbf B_o) + \\Omega\\tau E_\\eta\\nabla^2\\mathbf b \\\\ \\lambda\\theta = -\\mathbf u\\cdot\\nabla T_o + \\frac{\\Omega\\tau E}{Pr}\\nabla^2\\theta } \\] <p>Inviscid fluids (\\(\\nu = 0\\)) don't allow for the use of the Rayleigh number, while perfectly insulating fluids (\\(\\kappa = 0\\)) don't allow for the use of either the Rayleigh or Prandtl numbers. In this cases, the following non-dimensional number is better suited:</p> \\[ \\text{Brunt-V\u00e4is\u00e4l\u00e4 frequency:}\\ \\ N_o^2 = -\\frac{\\alpha g^*\\theta^*}{L} \\] <p>The (non-dimensional) momentum equation is then written as:</p> \\[ \\lambda\\mathbf u + 2(\\Omega\\tau)\\hat{\\mathbf z}\\times\\mathbf u = -\\nabla p-(\\Omega\\tau)^2\\frac{N_o^2}{\\Omega^2}\\theta\\mathbf g + (\\Omega\\tau E)\\nabla^2\\mathbf u + (\\Omega\\tau Le)^2(\\nabla\\times\\mathbf b)\\times\\mathbf B_o \\] <p>If both the Rayleigh and Prandtl numbers are defined, the following holds:</p> \\[ E^2\\frac{Ra}{Pr} = -\\frac{N_o^2}{\\Omega^2} \\] <p>Different non-dimensionalizations are now possible depending of the choice of the time scale \\(\\tau\\). Kore supports four different time scales, which are selected by prescribing the value of the \\(\\Omega\\tau\\) factor in one of the following ways:</p>"},{"location":"3nondim/#rotation-time-scale","title":"Rotation time scale","text":"<p>This time scale has \\(\\tau = 1/\\Omega\\), so that \\(\\Omega\\tau = 1\\). The non-dimensional equations read:</p> \\[ \\displaylines{ \\lambda\\mathbf u + 2\\hat{\\mathbf z}\\times\\mathbf u = -\\nabla p - E^2\\frac{Ra}{Pr}\\theta\\mathbf g + E\\nabla^2\\mathbf u + Le^2(\\nabla\\times\\mathbf b)\\times\\mathbf B_o \\\\ \\lambda\\mathbf b = \\nabla\\times(\\mathbf u\\times\\mathbf B_o) + E_\\eta\\nabla^2\\mathbf b \\\\ \\lambda\\theta = -\\mathbf u\\cdot\\nabla T_o + \\frac{E}{Pr}\\nabla^2\\theta } \\] <p>This time scale is not suitable for problems in which the domain does not rotate. This is not a problem because Kore does not consider this possibility.</p>"},{"location":"3nondim/#viscous-diffusion-time-scale","title":"Viscous diffusion time scale","text":"<p>This time scale has</p> \\[\\tau = \\frac{L^2}{\\nu} \\longrightarrow \\Omega\\tau = \\frac{1}{E}\\] <p>The non-dimensional equations read:</p> \\[ \\displaylines{ \\lambda\\mathbf u + \\frac{2}{E}\\hat{\\mathbf z}\\times\\mathbf u = -\\nabla p-\\frac{Ra}{Pr}\\theta\\mathbf g + \\nabla^2\\mathbf u + \\bigg(\\frac{Le}{E}\\bigg)^2(\\nabla\\times\\mathbf b)\\times\\mathbf B_o \\\\ \\lambda\\mathbf b = \\nabla\\times(\\mathbf u\\times\\mathbf B_o) + \\frac{E_\\eta}{E}\\nabla^2\\mathbf b \\\\ \\lambda\\theta = -\\mathbf u\\cdot\\nabla T_o + \\frac{1}{Pr}\\nabla^2\\theta } \\] <p>This time scale is not suitable for inviscid problems, where \\(\\nu = E = 0\\). Note also that, given the typical small values of \\(E\\) (in the other of \\(10^{-15}\\) for the Earth's liquid core), this is probably not the most suitable time scale in the general case.</p>"},{"location":"3nondim/#magnetic-diffusion-time-scale","title":"Magnetic diffusion time scale","text":"<p>This time scale has</p> \\[\\tau = \\frac{L^2}{\\eta} \\longrightarrow \\Omega\\tau = \\frac{1}{E_\\eta}\\] <p>The non-dimensional equations read:</p> \\[ \\displaylines{ \\lambda\\mathbf u + \\frac{2}{E_\\eta}\\hat{\\mathbf z}\\times\\mathbf u = -\\nabla p - \\bigg(\\frac{E}{E_\\eta}\\bigg)^2\\frac{Ra}{Pr}\\theta\\mathbf g + \\frac{E}{E_\\eta}\\nabla^2\\mathbf u + \\bigg(\\frac{Le}{E_\\eta}\\bigg)^2(\\nabla\\times\\mathbf b)\\times\\mathbf B_o \\\\ \\lambda\\mathbf b = \\nabla\\times(\\mathbf u\\times\\mathbf B_o) + \\nabla^2\\mathbf b \\\\ \\lambda\\theta = -\\mathbf u\\cdot\\nabla T_o + \\frac{E}{E_\\eta Pr}\\nabla^2\\theta } \\]"},{"location":"3nondim/#alfven-wave-time-scale","title":"Alfv\u00e9n wave time scale","text":"<p>This time scale has</p> \\[\\tau = \\frac{L\\sqrt{\\rho\\mu_o}}{B^*} \\longrightarrow \\Omega\\tau = \\frac{1}{Le}\\] <p>The non-dimensional equations read:</p> \\[ \\displaylines{ \\lambda\\mathbf u + \\frac{2}{Le}\\hat{\\mathbf z}\\times\\mathbf u = -\\nabla p-\\bigg(\\frac{E}{Le}\\bigg)^2\\frac{Ra}{Pr}\\theta\\mathbf g + \\frac{E}{Le}\\nabla^2\\mathbf u + (\\nabla\\times\\mathbf b)\\times\\mathbf B_o \\\\ \\lambda\\mathbf b = \\nabla\\times(\\mathbf u\\times\\mathbf B_o) + \\frac{E_\\eta}{Le}\\nabla^2\\mathbf b \\\\ \\lambda\\theta = -\\mathbf u\\cdot\\nabla T_o + \\frac{E}{LePr}\\nabla^2\\theta } \\]"},{"location":"4numerical/","title":"Numerical scheme","text":"<p>In order to solve the non-dimensional problem, the implementation of Kore is quite the opposite of straightforward, but the methods are traditional. Below, the translation between the non-dimensional equations and the software implementation will be presented. An attempt has been made at dividing this section and its steps in a way in which the relationship with the different parts of Kore are as clear as possible. The momentum equation without the Lorentz force and the rotation time scale is used to illustrate the procedure, which is extendable to all other equations and terms.</p> <p>In short, Kore writes \\(\\mathbf u\\) and \\(\\mathbf b\\) in their poloidal and toroidal components. Discretization of the problem is made in terms of frequency, with spherical harmonics serving for angular discretization and Chebyshev polynomials serving for radial discretization. The differential system in the unknowns then turns into a large algebraic linear system in their coefficients, which is solved as an eigenvalue problem if a forcing is not specified (or solved directly otherwise).</p>"},{"location":"4numerical/#poloidal-toroidal-decomposition-and-the-u-and-v-sections","title":"Poloidal-toroidal decomposition and the \\(u\\) and \\(v\\) sections","text":"<p>Possibly the best place to start could be the way in which the vector equations are dissected. This decomposition is not motivated by software, but rather has been a traditional manner in which to study rotating flows (see e.g. Tilgner 1999). It should be noted that, although it hasn't been explicitely mentioned in Physical Definition, a (quasi-)incompressible fluid can only produce a divergence-less velocity field \\(\\mathbf u\\) by virtue of the continuity equation. Similarly, Gauss' law for a magnetic field imposes a divergence-less induced magnetic field \\(\\mathbf b\\). These conditions impose further constraints on the relationship between the components of each vector field, reducing the number of actual free parameters from three per field to just two.</p> <p>Rather than using the actual components of the (e.g. velocity) field, it has been a traditional approach to express the vector by mean of two scalar quantites, \\(\\mathcal P\\) and \\(\\mathcal T\\), called the poloidal and toroidal potentials respectively, as follows:</p> \\[ \\mathbf u = \\nabla\\times\\nabla\\times(\\mathcal P\\mathbf r) + \\nabla\\times(\\mathcal T\\mathbf r) \\] <p>The magnetic field \\(\\mathbf b\\) is written in a similar way, but the poloidal and toroidal potentials are denoted \\(\\mathcal F\\) and \\(\\mathcal G\\) respectively. Note that, because \\(\\mathbf u\\) is given as the curls of vectors, the condition of zero divergence is automatically satisfied. However, because we now have two unknowns rather than three, the original momentum (or induction) equation cannot be used. Instead, the \\(u\\) and \\(v\\) sections are used. The \\(u\\) section is the radial projection of the second curl of the momentum equation (\\(\\hat{\\mathbf r}\\cdot\\nabla\\times\\nabla\\times\\)), while the \\(v\\) section is the radial projection of the first curl of the momentum equation (\\(\\hat{\\mathbf r}\\cdot\\nabla\\times\\)). For simplicity reasons, however, the projection will be performed here by dot-multiplication with \\(\\mathbf r\\) rather than \\(\\hat{\\mathbf r}\\). The same thing is done for the induction equation, where Kore now calls the sections \\(f\\) and \\(g\\) rather than \\(u\\) and \\(v\\) respectively. Each section is now one scalar equation, and the two sections together allow to solve for the two scalar unknowns.</p> <p>Finally, it will be explicitely noted that the poloidal and toroidal potentials are time-independent complex functions, by virtue of \\(\\mathbf u\\) (or \\(\\mathbf b\\)) having these same properties.</p>"},{"location":"4numerical/#angular-discretization-operators-and-symmetry","title":"Angular discretization, operators and symmetry","text":"<p>The introduction of the poloidal and toroidal potentials leaves us with a set of explicitely scalar equations and unknowns. Each of this unknowns is a complex number with a purely spatial dependance, which is advantegously expressed in terms of the radial \\(r\\), colatitude \\(\\theta\\) and longitude \\(\\varphi\\) spherical coordinates given the (quasi-)spherical symmetry of the problem at hand. It is thus reasonable to expand the unknowns in spherical harmonics \\(Y_l^m(\\theta,\\varphi) = e^{i\\varphi}P_l^m(\\cos\\theta)\\), with coefficients e.g. \\(\\mathcal P_{l,m}\\) that only depend on \\(r\\):</p> \\[ \\mathcal P = \\sum_{l=0}^{L}\\sum_{m = -l}^lP_{l,m}(r)Y_l^m(\\theta,\\varphi) \\] <p>To be rigurous, the equal sign can only hold if the upper bound of the summation over \\(l\\) is infinity, rather that some maximum degree \\(L\\). However, it is assumed that the maximum degree is chosen such that the truncated series is a good enough approximation to the infinite one so that one can make no distinction between the two. In this manner, one unknown function dependent upon all three coordinates is transformed into \\((L+1)^2\\) unknowns dependent upon \\(r\\). The velocity (or induced magnetic field) thus involves twice as many coefficients to account for both the poloida and toroidal potentials, each involving \\((L+1)^2\\) coefficients.</p> <p>This greatly simplifies the expressions for all the terms in the \\(u\\) and \\(v\\) sections. These sections can be built term by term, in what Kore calls operators. Consider, for example, the first term in the momentum equation, \\(\\lambda\\mathbf u\\) (see Non-dimensionalization). When writing the \\(v\\) section, this term will turn into \\(\\mathbf r\\cdot\\nabla\\times\\mathbf u\\). If one does the (very extensive) math, this is simply \\(-r^2\\nabla^2_s\\mathcal P\\), where \\(\\nabla^2_s\\) represents the surface laplacian, i.e. the standard laplacian with all radial derivatives removed. By virtue of the properties of the spherical harmonics, such a quantiy can be written as:</p> \\[ \\mathbf r\\cdot\\nabla\\times\\mathbf u = -r^2\\nabla^2_s\\mathcal P = \\sum_{l=0}^{L}\\sum_{m = -l}^ll(l+1)\\mathcal P_{l,m}(r)Y_l^m(\\theta,\\varphi) \\] <p>To simplify the notation, one may write just the \\(l,m\\) coefficients of that series as below:</p> \\[ (\\mathbf r\\cdot\\nabla\\times\\mathbf u)_{l,m} = l(l+1)\\mathcal P_{l,m} \\] <p>Kore calls this the operator \\(u\\) in the \\(v\\) section. A less trivial example - but a more informative one for later sections - is the viscous diffusion operator in the \\(u\\) section, i.e. the projected second curl of the viscous force:</p> \\[ (\\mathbf r\\cdot\\nabla\\times\\nabla\\times\\nabla^2\\mathbf u)_{l,m} = \\frac{d^4\\mathcal P_{l,m}}{dr^4} + \\frac{4}{r}\\frac{d^3\\mathcal P_{l,m}}{dr^3} - \\frac{2l(l+1)}{r^2}\\frac{d^2\\mathcal P_{l,m}}{dr^2} + \\frac{l(l+1)(l^2+l-2)}{r^4}\\mathcal P_{l,m} \\] <p>Such a process is followed for all the terms in the equation, through convenient use of the properties of spherical harmonics and their derivatives. Some need more algebra than others to be written in a useful manner. The Coriolis term results in a coupling between the poloidal and toroidal coefficients \\(\\mathcal P_{l,m}\\) and \\(\\mathcal T_{l,m}\\), so that each section \\(u\\) and \\(v\\) will in principle involve all \\(2(L+1)^2\\) unknowns. When putting all operators together, each section represents an equatlity between two series, so their coefficients are made to match. This results in a total of \\((L+1)^2\\) equations per section. The two sections then allow to solve all \\(2(L+1)^2\\) unknowns.</p> <p>When this process is carried out explicitely, however, two things occur that allow to reduce the size of the system:</p> <ul> <li>The equations for the \\(u\\) and \\(v\\) sections do not mix coefficients with different order \\(m\\), so that one could gather all equations with the same \\(m\\) and solve them independently. For this reason, Kore works in a per-order basis, where a value of \\(m\\) is specified and the appropriate system is built. Each order \\(m\\) contains only \\(2(L-|m|+1)\\) terms and unknowns.</li> <li>Within a fixed order \\(m\\), each poloidal coefficient \\(\\mathcal P_{l,m}\\) is only related in the \\(u\\) section with the toroidal coefficients of adjacent degree, i.e. \\(\\mathcal T_{l+1,m}\\) and \\(\\mathcal T_{l-1,m}\\). Similarly, the \\(v\\) section only relates each toroidal coefficient \\(\\mathcal T_{l,m}\\) with poloidal coefficients \\(\\mathcal P_{l+1,m}\\) and \\(\\mathcal P_{l-1,m}\\). This results in couplings that skip every other degree, so that poloidal coefficients of even degree will only be coupled with toroidal coefficients of odd degree - and viceversa. Thus, one could effectively build a system with only poloidal terms of a single parity and toroidal terms of the other parity. These only represent half of the coefficients, and so the size of the system is further reduced to just \\(L-|m|+1\\). Kore follows this simplification and only builds the system pertaining to the parity that is specified.</li> </ul> <p>This second point has geometric significance. Note that the parity of the spherical harmonic functions with respect to the \\(\\cos\\theta\\) variable is given by the parity of their degree: harmonics with even degree are even themselves. Thus, harmonics with even parity are symmetric across the equator, while harmonics with odd parity are antisymmetric. A solution yields a set of poloidal coefficients of one parity and a set of toroidal coefficients of the opposing parity. By writing the expressions out and reasoning what equatorial symmetry means for each of the three components of \\(\\mathbf u\\), it turns out that the parity of \\(\\mathbf u\\) is the same as that of \\(\\mathcal P\\) and opposite to that of \\(\\mathcal T\\). A system with even degrees for \\(\\mathcal P_{l,m}\\) produces a symmetric flow, and viceversa. It is this symmetry of the solution that Kore uses to build the appropriate system of equations.</p> <p>Note that this set of equations has two very distinct halves: one coming from the \\(u\\) section, the other coming from the \\(v\\) section. Within each half, the equations are exactly the same, but they just involve different poloidal-toroidal coefficients. If one was to write them in matrix form, where each entry is an operator, they would find that the rows within each half just get displaced.</p>"},{"location":"4numerical/#radial-discretization-inner-cores-and-symmetry-considerations","title":"Radial discretization, inner cores and symmetry considerations","text":"<p>The previous angular discretization results in a set of \\(L-|m|+1\\) ODEs in \\(r\\) to solve for all the involved poloidal-toroidal coefficients. To solve them numerically, the radial dependance of each coefficient on \\(r\\) is expressed in terms of Chebyshev functions \\(T_k(r)\\) as:</p> \\[ \\mathcal P_{l,m} = \\sum_{k=0}^N\\mathcal P_{l,m}^kT_k(r)\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\mathcal T_{l,m} = \\sum_{k=0}^N\\mathcal T_{l,m}^kT_k(r) \\] <p>Here, the coefficients \\(\\mathcal P_{l,m}^k\\) are constants and do not depend on any spatial coordinate. Again, the equalities should only hold for an infinite sum, but the truncated \\(N+1\\) term expansion is assumed to be good enough and indistinguishable from the infinite series. By means of this expansion, each one of the \\(L-|m|+1\\) equations obtained from the angular discretization can be written as an equality between two series, whose terms are made to match. Although the idea is the same as with the angular discretization, the process in this case is somewhat more complicated because the Chebyshev family does not offer as convenient differentiation properties as those of the spherical harmonics, but rather involve other families of polynomials jointly known as the ultraspherical or Gegenbauer polynomials. A detailed explanation of the full extent of the discretization in terms of Gegenbauer polynomials is provided by Olver and Townsend (2013). It is this algorithm that Kore implements, and a short keynote summary is provided here.</p> <p>The algorithm is thought of as working with vectors and vector bases. Each family of Gegenbauer polynomials has a generating function whose behaviour is determined by a parameter \\(\\lambda\\) and thus the family is denoted as \\(C^{(\\lambda)}\\), with each member of the family being denoted as \\(C^{(\\lambda)}_k\\). A function can be written as an expansion series with any of those families, and a vector collecting the coefficients of the series in each family is said to be in the basis of that family. Differentiation of a function written in a \\(C^{(\\lambda)}\\) series can be performed by means of a matrix operation \\(\\mathcal D_{\\lambda}\\), which acts on the vector of coefficients in the \\(C^{(\\lambda)}\\) basis and returns the coefficients of the derivative, now in the \\(C^{(\\lambda+1)}\\) basis. A second derivative is just the successive application of such a matrix, the result of which is provided in the \\(C^{(\\lambda+2)}\\) basis. One can imagine that an operator involving different derivatives of different orders, like the viscous diffusion operator above, will naturally involve vectors in different bases. Writing them in the same basis is achieved by pre-multiplication with a matrix \\(\\mathcal S_\\lambda\\), which takes a vector in the \\(C^{(\\lambda)}\\) basis and returns the coefficients of the same function in the \\(C^{(\\lambda+1)}\\) basis. Products between two functions can be done in Gegenbauer space by using a matrix \\(\\mathcal M_\\lambda\\), which is built with the coefficients of one of the functions and pre-multiplies the vector of coefficients of the other function. The result is the vector of coefficients of the product of the two functions. The inputs need to be in the same basis, and the output is given in that basis as well.</p> <p>In the end, each of the operators obtained in the angular discretization can be written by an appropriate combination of these \\(\\mathcal D_\\lambda\\), \\(\\mathcal S_\\lambda\\) and \\(\\mathcal M_\\lambda\\). This is exactly what Kore does. For each of the \\(L-|m|+1\\) equations obtained in the angular discretization, the operators apply on the vector of coefficients of each of the involved \\(\\mathcal P_{l,m}\\) and \\(\\mathcal T_{l,m}\\). Each of these scalar equations then turn into \\(N+1\\) scalar equations which, stacked together, constitue a system of \\((N+1)(L-|m|+1)\\) equations to solve for the same number of unknowns. This step effectively turns each entry of the matrix obtained with the angular discretization into a sub-matrix itself, while each entry in the unknown vector from before gets turned into a sub-vector itself. The structure that was mentioned earlier for the entries of the matrix in the angular discretization is maintained by the submatrices in this second discretization.</p> <p>Something important to keep in mind when using Chebyshev or Gegenbauer polynomials is that their domain is limited to the \\([-1,1]\\) interval. Therefore, the radial domain of the problem needs to be mapped accordingly. Here, two situations need to be distinguished.</p> <ul> <li>In the presence of an inner core, the radial domain is \\([r_{icb},r_{cmb}]\\). This interval of \\(r\\) is scaled and shifted to match the \\([-1,1]\\) interval of \\(x\\) as:</li> </ul> \\[ x = 2\\frac{r - r_{icb}}{r_{cmb} - r_{icb}} - 1 \\] <ul> <li>In the absence of an inner core, mapping the interval \\([0,r_{cmb}]\\) to the interval \\([-1,1]\\) creates conflicts at the origin (see Rekier et al., 2019) and it is more convenient to map the whole diameter \\([-r_{cmb}, r_{cmb}]\\) to the Chebyshev domain. This is done through the transformation:</li> </ul> \\[ x = \\frac{r}{r_{cmb}} \\] <p>In any case, the assumed symmetry that was used in the angular discretization is to be mantained, which imposes further restrictions on the shape of the radial functions. In the end, only Chebyshev polynomials with the same parity as the flow can be part of the solution, which is to say that all coefficients corresponding to the other parity need to vanish. Imposing this reduces the number of equations and unknowns by half, yielding a final system with \\((N+1)(L-|m|+1)/2\\) equations and unknowns.</p>"},{"location":"4numerical/#boundary-conditions-generalization-and-final-notes","title":"Boundary conditions, generalization and final notes","text":"<p>For a fully defined problem, the differential equation(s) discretized above need to be complemented with boundary conditions, all of which are discretized in exactly the same manner. TODO: Not sure about this. There is this part with generalized spherical harmonics and the canonical basis that I am not sure how it translates to the final matrix system.</p> <p>Although the numerical scheme has been illustrated using the momentum equation, exactly the same type of procedure can be followed for the induction equation and its \\(f\\) and \\(g\\) sections, and the already scalar equations of heat and composition. However, the induction equation involves a product of the induced field \\(\\mathbf b\\) and the background field \\(\\mathbf B_o\\), both of which are written in spherical harmonics (see . The product of two spherical harmonics involves the so-called Wigner 3-j symbols, which greatly complicates the analytical approach. In practice, in order to know what derivatives are needed in each operator, a Mathematica package called TenGSHui had been previously used, and the operators it output were implemented in Kore.</p> <p>Another final detail is that, in the implementation of Kore, factors of \\(1/r\\) have been removed from the differential equations for the \\(r\\)-dependent coefficients of the spherical harmonic expansions. These equations have been multiplied by whatever power of \\(r\\) is required to eliminate all \\(r\\) from the denominators. This renders all differential operators in \\(r\\) to be of the form \\(r^\\alpha(d/dr)^\\beta\\) with some \\(\\alpha,\\beta\\geq0\\).</p> <p>At the end of the whole discretization process, the whole system can be written in matrix form. Due to the shape of the original equations, this system will have two parts: one of them proportional to \\(\\lambda\\) - which has not really been fixed - and another part independent of it. This allows to write the system in the form \\(\\mathbf A\\mathbf x = \\lambda\\mathbf B\\mathbf x\\), with \\(\\mathbf x\\) being the vector containing all \\((N+1)(L-|m|+1)/2\\) unknowns. This is a (massive) generalized eigenvalue problem, which is not solved entirely but rather an algorithm is used to solve only for eigenvalues close to a specified ''fixed point''.</p>"},{"location":"5implementation/","title":"Software implementation","text":"<p>Although the physical problem and numerical method have been explained, using the code can - and will - be disorienting. Thus, an overall explanation of how the code is structured is presented below. This will cover most - but not all - of the files within the <code>bin</code> folder. The content below will be high level, aimed at relating the different parts of the code to what has been explained in the rest of this documentation. Low level details pertaining to e.g. the specific way in which matrices are built will not be given. </p>"},{"location":"5implementation/#running-the-software","title":"Running the software","text":"<p>It is to be noted that some pre-operatorions are required to run Kore, namely exporting all required paths and activating the environment (see Installation and the README file in the Kore Github repo). All this will be assumed to have been done. Another important aspect of Kore is that it is parallelized. Parallelization-related commands and code will therefore be intertwined with Kore's code per se. Parallelization details will not be discussed here, though.</p>"},{"location":"5implementation/#general-workflow","title":"General workflow","text":""},{"location":"5implementation/#defining-the-problem","title":"Defining the problem","text":"<p>The first step to solve a problem with Kore is, well, to define a problem. This is done in the <code>parameters.py</code> file. It is here where the equations that need to be solved are selected, among those explained in Physical definition. This file is generally divided in big sections pertaining to each of the equations, where the relevant non-dimensional quantities are also defined. For instance, the section devoted to the momentum equation contains the value of the Ekmann number, while the section devoted to induction contains the value of the Lenhert and magnetic Ekmann numbers. After all sections, the value of \\(\\Omega\\tau\\) is selected (see Non-dimensionalization), which sets the non-dimensionalization and the final form of the equations.</p> <p>Another thing that is done in this file, under a section called <code>Resolution</code>, is fixing the truncation order for the Chebyshev expansions and the truncation degree for the spherical harmonic expansions. The former can be done either manually or according to the Ekmann number, while the latter is determined according to the number of CPUs used in the parallelization. In this regard, it was mentioned in Numerical scheme that Kore solves the problem in a per-order basis, and only for a given symmetry of the solution. These two elements are also set in this file, under the <code>hydrodynamic parameters</code> section.</p> <p>The last section in this file is devoted to SLEPc, the algorithm to solve for the eigenvalues of the problem. Here, the ''fixed point'' mentioned in Numerical scheme is set, as well as the maximum number of iterations or the required tolerance in the obtained eigenvalues.</p>"},{"location":"5implementation/#building-the-submatrices","title":"Building the submatrices","text":"<p>The next step is just building the system of equations. It was explained in Numerical scheme that the equations in this system - which results from the angular discretization - will be determined by the order \\(m\\) and symmetry of the solution and that, when written in matrix form, each entry of the matrix will be a differential operator. In the radial discretization, however, each of these operators is turned into a sub-matrix itself, all coming from the Chebyshev discretization scheme (see Numerical scheme or Olver and Townsend, 2013). Thus, in order to build the whole system, these submatrices are built first. This is done by running the <code>submatrices.py</code> file. Running this file requires one argument: the number of cores. Once the submatrices are built they are written to txt-like files with the <code>.mtx</code> extension. These files are stored one directory above the <code>submatrices.py</code> file itself.</p>"},{"location":"5implementation/#assembling-the-system","title":"Assembling the system","text":"<p>The next step is assembling these submatrices into the bigger system, namely into matrices \\(\\mathbf A\\) and \\(\\mathbf B\\) of the generalized eigenvalue problem. This is done in the <code>assemble.py</code>, which should be run next. This task is parallelized with MPI, and the command that should be run from the command line is</p> <pre><code>mpiexec -n [NUMBER OF CORES] [PATH]/assemble.py\n</code></pre> <p>If all goes well, the matrices should be written in the <code>A.mtx</code> and <code>B.mtx</code> files together with all other submatrices.</p>"},{"location":"5implementation/#solving-the-system","title":"Solving the system","text":"<p>Once these two matrices are built, all that is left is to solve the system. Some options for the SLEPc solver are required first, so they should be specified with the command</p> <pre><code>export opts='-st_type sinvert -eps_error_relative ::ascii_info_detail -eps_balance twoside -pc_factor_mat_solver_type mumps -mat_mumps_icntl_14 10000'\n</code></pre> <p>TODO: No estoy muy seguro de qu\u00e9 significa cada una de estas opciones. Solo he corrido este commando una vez bajo ordern directa y expresa de Andr\u00e9s. Yo en realidad solo soy un mandao.</p> <p>With these options, the command to run the <code>solve.py</code> can be run, which is also done in paraller with MPI:</p> <pre><code>mpiexec -n [NUMBER OF CORES] [PATH]/solve.py $opts\n</code></pre> <p>If all goes well, the solution is written into txt files. If solved as an eigenvalue problem, the eigenvalues are written to an <code>eigenvalues0.dat</code> file. The eigenvectors are written to files with the <code>.field</code> extension. In a solved problem, these files do not contain the eigenvectors but rather the response vectors. These vectors are just segments of the massive vector containing all Chebyshev coefficients of all spherical harmonic coefficients of all scalar variables. The part pertaining to the hydrodynamic equations contains both the \\(\\mathcal P\\) and \\(\\mathcal T\\) potentials, while the part pertaining to the induced magnetic field contains both the \\(\\mathcal F\\) and \\(\\mathcal G\\) potentials. TODO: Eso \u00faltimo me lo he inventado jajajaja</p>"},{"location":"5implementation/#post-processing-the-solution","title":"Post processing the solution","text":"<p>In an eigenvalue problem, the quality of the converged solution obtained with SLEPc can be checked by running the <code>spin_doctor.py</code> file, which provides TODO: Ni idea de qu\u00e9 provides.</p> <p>On the other hand, the eigenvectors - or forced solution - can be visualized by running the <code>plot_field.py</code> file.</p>"}]}