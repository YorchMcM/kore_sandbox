#!/usr/bin/env python3
'''
tintin assembles

Use as:
mpiexec -n ncpus  ./assemble.py
ncpus should match the value in the parameters.py file

This program takes the block matrices generated by submatrices.py
and assembles the matrix A, the matrix B, or the forcing vector.
'''

from timeit import default_timer as timer
import scipy.sparse.linalg as ssl
import scipy.sparse as ss
import pywigxjpf as wig
from mpi4py import MPI
import scipy.io as sio
import numpy as np
import warnings
import sys

import bc_variables as bv
import parameters as par
import utils as ut


#n  = int(par.N*(par.lmax-par.m+1)/2.)
#nb = int((par.lmax-par.m+1)/2.)
#n  = par.N*nb


def main():
	
	warnings.simplefilter('ignore', ss.SparseEfficiencyWarning)
	
	# initialize Wigner-3j symbols table		
	wig.wig_table_init(2*( par.lmax + 5), 3)
	wig.wig_temp_init(2*( par.lmax + 5))

	comm  = MPI.COMM_WORLD
	sizas = comm.Get_size()
	rank  = comm.Get_rank()
	
	if rank == 0:
		alltop = np.arange( ut.m_top, ut.lmax_top, 2, dtype=int) # array with l's for 2curl eqs
		allbot = np.arange( ut.m_bot, ut.lmax_bot, 2, dtype=int) # array with l's for 1curl eqs
	else:
		alltop = None
		allbot = None
	
	nb = int((par.lmax - par.m + 1)/2) 	# number of block rows per quarter
	bpp = int(nb/sizas) 	# block rows per process
	
	loc_top = np.zeros(bpp, dtype=int)
	loc_bot = np.zeros(bpp, dtype=int)
	
	# split the vectors with l values and send to all cpu's (ranks)
	comm.Scatter(alltop, loc_top, root=0)
	comm.Scatter(allbot, loc_bot, root=0)

	# read submatrices
	# top (for double curl eqs)
	r4D4t = ss.csr_matrix(sio.mmread('r4D4t'))
	r4D3t = ss.csr_matrix(sio.mmread('r4D3t'))
	r4D2t = ss.csr_matrix(sio.mmread('r4D2t'))
	r4D1t = ss.csr_matrix(sio.mmread('r4D1t'))
	r4It  = ss.csr_matrix(sio.mmread('r4It'))
	
	r3D3t = ss.csr_matrix(sio.mmread('r3D3t'))
	r3D2t = ss.csr_matrix(sio.mmread('r3D2t'))
	r3D1t = ss.csr_matrix(sio.mmread('r3D1t'))
	r3It  = ss.csr_matrix(sio.mmread('r3It'))
	
	r2D2t = ss.csr_matrix(sio.mmread('r2D2t'))
	r2D1t = ss.csr_matrix(sio.mmread('r2D1t'))
	r2It  = ss.csr_matrix(sio.mmread('r2It'))
	
	r1It  = ss.csr_matrix(sio.mmread('r1It'))
	It    = ss.csr_matrix(sio.mmread('It'))
	
	#S3210 = ss.csr_matrix(sio.mmread('S3210'))
	
	# bottom (for single curl eqs)
	r2D2b = ss.csr_matrix(sio.mmread('r2D2b'))
	r2D1b = ss.csr_matrix(sio.mmread('r2D1b'))
	r2Ib  = ss.csr_matrix(sio.mmread('r2Ib'))
	r1D1b = ss.csr_matrix(sio.mmread('r1D1b'))
	r1Ib  = ss.csr_matrix(sio.mmread('r1Ib'))
	Ib    = ss.csr_matrix(sio.mmread('Ib'))


	if par.forcing == 1: # --------------------------------------------------------------------------------- Yufeng forcing
		'''
		Builds the right hand side vector for the forced problem
		Lin 2018 body forcing
		l=3, m=2 Toroidal scalar only
		equatorially symmetric
		'''
		if rank == 0: # only one cpu is enough
			
			if par.symm==1 and par.m==2:
		
				pos = ut.n + par.N*np.where(allbot==3)[0][0] # finds where the l=3 toroidals begin 
				row = np.arange(pos,pos+par.N) # start at pos+2 because of the 2 rows with bc's
				col = np.zeros(par.N)

				bdat = Ib*ut.chebco(-2, par.N, 3e-16, par.ricb, ut.rcmb) * ( -4*np.sqrt(5)*(par.ricb**5)/(1-par.ricb**5) ) * par.forcing_amplitude
				B = ss.csr_matrix( ( bdat, (row,col) ), shape=(ut.sizmat,1) )
				
				np.savez('B_forced.npz', data=B.data, indices=B.indices, indptr=B.indptr, shape=B.shape)
			
			else:
			
				print('Lin & Ogilvie 2018 forcing needs symm = 1 and m = 2') 
		
		
	elif par.forcing == 2: # -------------------------------------------------------------- Jeremy's eccentricity tide forcing
		'''
		Builds the right hand side vector for the forced problem.
		This is Jeremy's tidal forcing as a boundary flow,
		l=2 Poloidal scalar only, equatorially symmetric.
		'''
		if rank == 0:
			
			if par.symm == 1 and (par.m==0 or par.m==2) and (par.bci+par.bco==2):
						
				pos = par.N*np.where(alltop==2)[0][0]
				row = np.arange(pos,pos+4)  # forcing goes as a boundary condition
				col = np.zeros(4)
				
				fcmb = 1j*par.forcing_amplitude * ut.eccen_tide(par.m*sign(par.forcing_frequency),par.ricb,'cmb')
				ficb = 1j*par.forcing_amplitude * ut.eccen_tide(par.m*sign(par.forcing_frequency),par.ricb,'icb')
		
				bdat = np.array([ficb[0], ficb[1], fcmb[0], fcmb[1]])
				B = ss.csr_matrix( ( bdat, (row,col) ), shape=(ut.sizmat,1) )
				
				np.savez('B_forced.npz', data=B.data, indices=B.indices, indptr=B.indptr, shape=B.shape)
			
			else:
				
				print('Jeremy\'s forcing needs symm = 1 and m = 0 or 2 and bci=bco=1')
				
				
	elif par.forcing == 3: # -------------------------------------------------------------------------------- Marc's forcing
		'''
		Builds the right hand side vector for forced problems
		This is the tidal forcing from Rovira-Navarro et al 2018
		'''
		if rank == 0:
			
			if par.m < 3:
			
				l = 3  # goes with the toroidals (1curl eqs)
				pos3 = ut.n + par.N*np.where(allbot==l)[0][0]
				row3 = np.arange(pos3+2,pos3+par.N)
				col3 = np.zeros(par.N-2)
				bdat3 = ut.marc_tide(ut.wf,3,par.m,'bot',par.N, par.ricb, ut.rcmb)*par.forcing_amplitude
				tmp = [bdat3, row3, col3]
				blist = tmp
				
				l = 2 # goes with the poloidals (2curl eqs)
				pos2 = par.N*np.where(alltop==l)[0][0]
				row2 = np.arange(pos2+4,pos2+par.N)
				col2 = np.zeros(par.N-4)
				bdat2 = ut.marc_tide(ut.wf,2,par.m,'top',par.N, par.ricb, ut.rcmb)*par.forcing_amplitude
				tmp = [bdat2, row2, col2]
				for q in [0,1,2]:
					blist[q]= np.concatenate((blist[q], tmp[q]))
				
				if par.m < 2:
					l = 1 # goes with the toroidals (1curl eqs)
					pos1 = ut.n + par.N*np.where(allbot==l)[0][0]
					row1 = np.arange(pos1+2,pos1+par.N)
					col1 = np.zeros(par.N-2)
					bdat1 = ut.marc_tide(ut.wf,1,par.m,'bot',par.N, par.ricb, ut.rcmb)*par.forcing_amplitude
					tmp = [bdat1, row1, col1]
					for q in [0,1,2]:
						blist[q]= np.concatenate((blist[q], tmp[q]))
						
				B = ss.csr_matrix( ( blist[0], (blist[1],blist[2]) ), shape=(ut.sizmat,1) )
				
				np.savez('B_forced.npz', data=B.data, indices=B.indices, indptr=B.indptr, shape=B.shape)
				
			else:
				
				print('Rovira-Navarro forcing requires m < 3')
			
			
	elif par.forcing == 4: # ------------------------------------------------------- forcing test 1 (Jeremy's body forcing)
		# see mathematica notebook forcing_test1_jeremy.nb
		if rank == 0:
			print('Jeremy\'s body forcing')
			if par.symm == 1 and par.m == 2:
				
				X = ut.ftest1(par.ricb)
				XA = X[0]
				XB = X[1]
				XC = X[2]
				
				l = 3 # goes with the toroidals (1curl eqs), Gegenbauer order 2 basis
				
				F2 = Ib*ut.chebco(-2, par.N, 3e-16, par.ricb, ut.rcmb)
				
				#bdat = Ib*chebco(-2,par.N,3e-16) * ( -4*np.sqrt(5)*(par.ricb**5)/(1-par.ricb**5) ) * par.forcing_amplitude
				#print(F2[:4])
				
				pos3 = ut.n + par.N*np.where(allbot==l)[0][0]
				row3 = np.arange(pos3, pos3 + par.N)
				col3 = np.zeros(par.N)
				bdat3 = par.forcing_amplitude * (-4*np.sqrt(5))*XB*F2 *XC
				tmp = [bdat3, row3, col3]
				blist = tmp
				
				B = ss.csr_matrix( ( blist[0], (blist[1],blist[2]) ), shape=(ut.sizmat,1) )
				np.savez('B_forced.npz', data=B.data, indices=B.indices, indptr=B.indptr, shape=B.shape)
				
			else:
				print('Forcing test 1 requires m = 2') 	
				
			
			
			
	elif par.forcing == 5: # ------------------------------------------------------- forcing test 2
		
		if rank == 0:
			
			if par.m == 0:
			
				F2 = r2Ib*ut.chebco(-2, par.N, 3e-16, par.ricb, ut.rcmb)
				
				l = 1 # goes with the toroidals (1curl eqs), Gegenbauer order 2 basis
				pos1 = ut.n+par.N*np.where(allbot==l)[0][0]
				row1 = np.arange(pos1,pos1+par.N)
				col1 = np.zeros(par.N)
				bdat1 = par.forcing_amplitude * (-4/5)*F2
				print(bdat1[:6])
				tmp = [bdat1, row1, col1]
				blist = tmp
				
				l = 3 # goes with the toroidals (1curl eqs), Gegenbauer order 2 basis
				
				pos3 = ut.n+par.N*np.where(allbot==l)[0][0]
				row3 = np.arange(pos3,pos3+par.N)
				col3 = np.zeros(par.N)
				bdat3 = par.forcing_amplitude * (-36/5)*F2
				print(bdat3[:6])
				tmp = [bdat3, row3, col3]
				for q in [0,1,2]:
					blist[q]= np.concatenate((blist[q], tmp[q]))
				
				B = ss.csr_matrix( ( blist[0], (blist[1],blist[2]) ), shape=(ut.sizmat,1) )
				np.savez('B_forced.npz', data=B.data, indices=B.indices, indptr=B.indptr, shape=B.shape)
				
			else:
				
				print('Forcing test 2 requires m = 0') 	
				
				
	elif par.forcing == 6: # ------------------------------------------------------- Buffett 2010 ICB radial velocity forcing
		
		if rank == 0:
			print('Buffett 2010 ICB radial velocity forcing')			
		
			if par.m == 1 and par.symm == -1:
			
				l = 2 # goes with the poloidals (2curl eqs) at the rows for the ICB boundary conditions
			
				pos = par.N*np.where(alltop==l)[0][0]  # pos should be zero
				row = np.arange(pos,pos+2)
				col = np.zeros(2)
				
				hft = 0.0025 # Inner core hydrostating flattening
				C   = (1j)*(2/3)*np.sqrt(6)*hft*par.ricb
				
				P   = ( par.ricb/(l*(l+1)) ) * C * par.forcing_amplitude
				dP  = -P/par.ricb
				d2P = (2-l*(l+1))*P/(par.ricb**2)
			
				if par.bci == 0: # stress-free
					#bdat = -1j*ut.wf*np.array([P, d2P])
					bdat = np.array([P, d2P])
					
				elif par.bci == 1: # no-slip
					#bdat = -1j*ut.wf*np.array([P,  dP])
					bdat = np.array([P,  dP])
			
				B = ss.csr_matrix( ( bdat, (row,col) ), shape=(ut.sizmat,1) )
				np.savez('B_forced.npz', data=B.data, indices=B.indices, indptr=B.indptr, shape=B.shape)
				
			else:
				
				print('Buffet2010 forcing requires m = 1, symm = -1')
				
				
				
	elif par.forcing == 7: # -------------------------------------------------------- longitudinal libration forcing 
		
		# boundary libration in longitude
		if rank == 0:
			print('Longitudinal libration')
			
			if par.m == 0 and par.symm == 1 and par.bci == 1 and par. bco == 1:
				
				l = 1   # l=1 Toroidal boundary forcing
			
				pos = ut.n + par.N*np.where(allbot==l)[0][0]
				#print(pos-ut.n)
				row = np.arange(pos,pos+2)
				col = np.zeros(2)
				#bdat = np.array([1j*par.ricb*par.forcing_amplitude, 1j*par.forcing_amplitude])
				bdat = np.array([1j*0.094*par.forcing_amplitude, 1j*par.forcing_amplitude])
				
				B = ss.csr_matrix( ( bdat, (row,col) ), shape=(ut.sizmat,1) )
				np.savez('B_forced.npz', data=B.data, indices=B.indices, indptr=B.indptr, shape=B.shape)
	
			else:
				
				print('Longitudinal ibration requires m = 0, symm = 1 and no-slip boundaries')
		
		
		
		
			

	
		
	elif par.forcing == 0: # -------------------------------------------------------- B matrix, no forcing (eigenvalue problem)
		'''
		Builds the right hand side B matrix to solve
		the generalized eigenvalue problem A.x = lambda.B.x
		'''
		if rank == 0:
			tic = timer()
		# ---------------------------------------------------------------------- B, u_pol, 2curl (hydro)
		for k,l in enumerate(loc_top):
		
			row = ( rank*bpp + k )* par.N
			col = row
		
			L = l*(l+1)
		
			# Physics --------------------------
			block = L*(r4D2t + 2*r3D1t - L*r2It)
			# ----------------------------------
	
			# update loc_list
			block.eliminate_zeros()	
			block = block.tocoo()
			tmp = [block.data, block.row, block.col]
			tmp[1] = tmp[1] + row
			tmp[2] = tmp[2] + col
			if l == loc_top[0]:
				loc_list = tmp
			else:
				for q in [0,1,2]:
					loc_list[q]= np.concatenate((loc_list[q], tmp[q]))
		
		# ---------------------------------------------------------------------- B, u_tor, 1curl (hydro)
		for k,l in enumerate(loc_bot):
		
			row = nb*par.N + ( rank*bpp + k )* par.N
			col = row

			L = l*(l+1)
	
			# Physics -----
			block = -L*r2Ib
			# -------------

			# update loc_list
			block.eliminate_zeros()
			block = block.tocoo()
			tmp = [block.data, block.row, block.col]
			tmp[1] = tmp[1] + row
			tmp[2] = tmp[2] + col
			for q in [0,1,2]:
				loc_list[q]= np.concatenate((loc_list[q], tmp[q]))
			
		
		if par.magnetic == 1: # adds (d/dt)*b in the induction equation to matrix B
			
			# ------------------------------------------------------------------ B, b_pol, nocurl (induction)
			for k,l in enumerate(loc_bot): 	# loc_bot here because of applied
											# field symmetry
				row = 2*nb*par.N + ( rank*bpp + k )* par.N
				col = row
		
				L = l*(l+1)
		
				# Physics ----
				block = L*r2Ib
				# ------------
	
				# update loc_list
				block.eliminate_zeros()	
				block = block.tocoo()
				tmp = [block.data, block.row, block.col]
				tmp[1] = tmp[1] + row
				tmp[2] = tmp[2] + col
				for q in [0,1,2]:
					loc_list[q]= np.concatenate((loc_list[q], tmp[q]))
	

			# ------------------------------------------------------------------ B, b_tor, 1curl (induction)
			for k,l in enumerate(loc_top):	# loc_top here because of applied
											# field symmetry
				row = 3*nb*par.N + ( rank*bpp + k )* par.N
				col = row

				L = l*(l+1)

				# Physics ----
				block = L*r2Ib
				# ------------

				# update loc_list
				block.eliminate_zeros()
				block = block.tocoo()
				tmp = [block.data, block.row, block.col]
				tmp[1] = tmp[1] + row
				tmp[2] = tmp[2] + col
				for q in [0,1,2]:
					loc_list[q]= np.concatenate((loc_list[q], tmp[q]))	
	
	
	
				
		# ---------------------------------------------------------------------- B matrix assembly
		# We use comm.Allgather here to figure out the right size 
		# for the local variables bdat, brow and bcol.
		# They all need to be the same size for comm.Gather to work with them.
		 
		s = np.shape(loc_list[0])[0]
		alls = comm.allgather(s)
		length = max(alls)
		
		bdat = np.zeros(length)
		brow = -np.ones(length)
		bcol = -np.ones(length)
	
		bdat[:s] = loc_list[0]
		brow[:s] = loc_list[1]
		bcol[:s] = loc_list[2]
		
		# fdat, frow and fcol are variables that will store the full B matrix
		# a Gather command will send all local data from each rank (bdat, brow, bcol)
		# to the rank 0 process.
		
		fdat = None
		frow = None
		fcol = None
		
		# We need to initialize explicitely the variables in rank 0:
		if rank == 0:
			fdat = np.zeros(length*sizas)
			frow = np.zeros(length*sizas)
			fcol = np.zeros(length*sizas)
		
		# and finally gather all local data to (fdat,frow,fcol) 
		comm.Gather(bdat,fdat,root=0)
		comm.Gather(brow,frow,root=0)
		comm.Gather(bcol,fcol,root=0)
	
		if rank == 0:
		
			ix = np.where(frow >= 0)
			B = ss.csr_matrix( ( fdat[ix], (frow[ix], fcol[ix]) ) , shape=(ut.sizmat,ut.sizmat) )
			Bnorm = ssl.norm(B)
			B = B/Bnorm
		
			toc = timer()
			print('Matrix B assembled in', toc-tic, 'seconds')
			tic = timer()

			np.savez('B.npz', data=B.data, indices=B.indices, indptr=B.indptr, shape=B.shape)
			toc = timer()
			print('Matrix B written to disk in', toc-tic, 'seconds')
		
		comm.Barrier()
	
	
	
	
	
	if rank == 0:
		tic = timer()

	# -------------------------------------------------------------------------------------------------- A matrix, 2curl hydro
	
	for k,l in enumerate(loc_top): # 2curl hydro eqs
		
		L = l*(l+1)
		row = ( rank*bpp + k )* par.N
		
		# Poloidal velocity terms
		# ---------------------------------------------------------------------- A, u_pol, 2curl (hydro)
		
		col0 = ( rank*bpp + k )* par.N
		
		# Physics----------------------------------------------
		visc =  -r4D4t - 4*r3D3t + 2*L*r2D2t - L*(l-1)*(l+2)*It  
		cori = ( 2.j*par.m )*( r4D2t + 2*r3D1t - L*r2It )
		iwu  = L*( - r4D2t - 2*r3D1t + L*r2It )*(1j*ut.wf)
		tmp = iwu + cori - par.Ek*L*visc
		# -----------------------------------------------------
		
		# bookkeeping
		tmp.eliminate_zeros()
		tmp = tmp.tocoo()
		blk0 = [tmp.data, tmp.row + row , tmp.col + col0]
		# -----------------------------------------------
		# create or update loc_list
		if l == loc_top[0]:
			loc_list = blk0
		else:
			for q in [0,1,2]:
				loc_list[q]= np.concatenate((loc_list[q], blk0[q]))


		# Toroidal velocity terms
		# ---------------------------------------------------------------------- A, u_tor, 2curl (hydro)
		
		# l-1 terms ---------------------------------------
		if ((l-1 >= ut.m_top) and (ut.symm1==1)) or (ut.symm1==-1) :
			
			if ut.symm1 == 1 :
				col1a = nb*par.N + ( rank*bpp + k - 1 )*par.N # left of diag if symm
			elif ut.symm1 == -1 :
				col1a = nb*par.N + ( rank*bpp + k )*par.N # on diag if antisymm	
			
			C = (l**2-1.)*np.sqrt(l**2-par.m**2) / (2*l-1.)
			
			# Physics -------------------------
			cori = 2.*C*( (l-1.)*r3It - r4D1t )
			tmp = cori
			# ---------------------------------
			
			# bookkeeping
			tmp.eliminate_zeros()
			tmp = tmp.tocoo()
			blk = [tmp.data, tmp.row + row, tmp.col + col1a]
			for q in [0,1,2]:	
				loc_list[q]= np.concatenate( ( loc_list[q], blk[q] ) )

		# l+1 terms --------------------------------------------
		if ((l+1 <= ut.lmax_top-1) and (ut.symm1==-1)) or (ut.symm1==1) :
			
			if ut.symm1 == -1 :
				col1b = nb*par.N + ( rank*bpp + k + 1 )* par.N # right of diag if antisymm
			elif ut.symm1 == 1 :
				col1b = nb*par.N + ( rank*bpp + k )* par.N # on diag if symm
			
			C = l*(l+2.)*np.sqrt((l+par.m+1.)*(l-par.m+1)) / (2.*l+3.)
			
			# Physics --------------------------
			cori = -2.*C*( (l+2.)*r3It + r4D1t )
			tmp = cori
			# ----------------------------------
			
			# bookkeeping
			tmp.eliminate_zeros()
			tmp = tmp.tocoo()
			blk = [tmp.data, tmp.row + row, tmp.col + col1b]
			for q in [0,1,2]:	
				loc_list[q]= np.concatenate( ( loc_list[q], blk[q] ) )

			
		# -----------------------------------------------------------
		# include velocity boundary conditions and update loc_list
		bc_u_list = bc_u_spherical( l, '2curl' )
		for q in [0,1,2]:	
			loc_list[q]= np.concatenate( ( loc_list[q], bc_u_list[q] ) )
		# -----------------------------------------------------------



		if par.magnetic == 1: # includes Lorentz force, applied uniform field along z
			
			
			# Lorentz force, poloidal magnetic field terms 
			# ------------------------------------------------------------------ A, b_pol, 2curl (hydro, Lorentz)
			
			# l-1 terms ---------------------------------------
			if ((l-1 >= ut.m_top) and (ut.symm1==1)) or (ut.symm1==-1) :
			
				if ut.symm1 == 1 :
					col2a = 2*nb*par.N + ( rank*bpp + k - 1 )* par.N # left of diag if symm
				elif ut.symm1 == -1 :
					col2a = 2*nb*par.N + ( rank*bpp + k )* par.N # on the diag if antisymm	
			
				C = np.sqrt(l**2-par.m**2)*(l**2-1)/(2*l-1)
				
				# Physics -----------------------------------------------
				lore = C*( L*(l-1)*r1It - L*r2D1t - (l-3)*r3D2t + r4D3t )
				tmp = lore*par.Le2
				# -------------------------------------------------------
			
				# bookkeeping
				tmp.eliminate_zeros()
				tmp = tmp.tocoo()
				blk = [tmp.data, tmp.row + row, tmp.col + col2a]
				for q in [0,1,2]:	
					loc_list[q]= np.concatenate( ( loc_list[q], blk[q] ) )
			
			
			# l+1 terms --------------------------------------------
			if ((l+1 <= ut.lmax_top-1) and (ut.symm1==-1)) or (ut.symm1==1) :
			
				if ut.symm1 == -1 :
					col2b = 2*nb*par.N + ( rank*bpp + k + 1 )*par.N # right of diag if antisymm
				elif ut.symm1 == 1 :
					col2b = 2*nb*par.N + ( rank*bpp + k )* par.N # on diag if symm	
			
				C = np.sqrt((1+l+par.m)*(1+l-par.m))*l*(l+2)/(2*l+3)
				
				# Physics ------------------------------------------------
				lore = C*( -L*(l+2)*r1It - L*r2D1t + (l+4)*r3D2t + r4D3t )
				tmp = lore*par.Le2
				# --------------------------------------------------------
			
				# bookkeeping
				tmp.eliminate_zeros()
				tmp = tmp.tocoo()
				blk = [tmp.data, tmp.row + row, tmp.col + col2b]
				for q in [0,1,2]:	
					loc_list[q]= np.concatenate( ( loc_list[q], blk[q] ) )
					

			# Lorentz force, toroidal magnetic field terms
			# ------------------------------------------------------------------ A, b_tor, 2curl (hydro, Lorentz)

			col3 = 3*nb*par.N + row
		
			# Physics -------------------------------
			lore = 1j*par.m*( -L*r2It + 2*r3D1t + r4D2t )
			tmp = lore*par.Le2
			# ---------------------------------------
		
			# bookkeeping
			tmp.eliminate_zeros()
			tmp = tmp.tocoo()
			blk = [tmp.data, tmp.row + row, tmp.col + col3]
			for q in [0,1,2]:	
					loc_list[q]= np.concatenate( ( loc_list[q], blk[q] ) )


		
	# ------------------------------------------------------------------------------------------------------ A matrix, 1curl hydro
	
	for k,l in enumerate(loc_bot): # 1curl Navier-Stokes equations
	
		L = l*(l+1.)
		row = nb*par.N + (rank*bpp + k )* par.N
		
		# Poloidal velocity terms
		# ---------------------------------------------------------------------- A, u_pol, 1curl (hydro)
		
		# l-1 terms ---------------------------------------
		if ((l-1 >= ut.m_bot) and (ut.symm1==-1)) or (ut.symm1==1) :
			
			if ut.symm1 == -1 :
				col0a = ( rank*bpp + k - 1 )* par.N	# left of diag if antisymm
			elif ut.symm1 == 1 :
				col0a = ( rank*bpp + k )* par.N   	# on the diag if symm	
			
			C = (l**2-1)*np.sqrt(l**2-par.m**2)/(2*l-1)
			
			# Physics ------------------------
			cori = 2*C*( (l-1.)*r1Ib - r2D1b )
			tmp = cori
			# --------------------------------
			
			# bookkeeping
			tmp.eliminate_zeros()
			tmp = tmp.tocoo()
			blk = [tmp.data, tmp.row + row, tmp.col + col0a]
			for q in [0,1,2]:	
				loc_list[q]= np.concatenate( ( loc_list[q], blk[q] ) )
			
			
		# l+1 terms --------------------------------------------
		if ((l+1 <= ut.lmax_bot-1) and (ut.symm1==1)) or (ut.symm1==-1) :
			
			if ut.symm1 == 1 :
				col0b = ( rank*bpp + k + 1 )* par.N	# right of diag if symm
			elif ut.symm1 == -1 :
				col0b = ( rank*bpp + k )* par.N		# on diag if antisymm
				
			C = l*(l+2)*np.sqrt((l+1+par.m)*(l+1-par.m))/(2*l+3)
			
			# Physics --------------------------
			cori = 2.*C*( -(l+2.)*r1Ib - r2D1b )
			tmp = cori
			# ----------------------------------
			
			# bookkeeping
			tmp.eliminate_zeros()
			tmp = tmp.tocoo()
			blk = [tmp.data, tmp.row + row, tmp.col + col0b]
			for q in [0,1,2]:	
				loc_list[q]= np.concatenate( ( loc_list[q], blk[q] ) )				
	
	
		# Toroidal velocity terms
		# ---------------------------------------------------------------------- A, u_tor, 1curl (hydro)

		col1 = nb*par.N + ( rank*bpp + k )* par.N
		
		# Physics -------------------
		visc = r2D2b + 2*r1D1b - L*Ib
		cori = -2j*par.m*r2Ib
		iwu  = L*r2Ib*(1j*ut.wf)
		tmp = iwu + cori - par.Ek*L*visc
		# ---------------------------
		
		# bookkeeping
		tmp.eliminate_zeros()
		tmp = tmp.tocoo()
		blk = [tmp.data, tmp.row + row, tmp.col + col1]		
		for q in [0,1,2]:	
				loc_list[q]= np.concatenate( ( loc_list[q], blk[q] ) )


		# -----------------------------------------------------------
		# include boundary conditions and update loc_list
		bc_u_list = bc_u_spherical( l, '1curl' )
		for q in [0,1,2]:	
			loc_list[q]= np.concatenate( ( loc_list[q], bc_u_list[q] ) )
		# -----------------------------------------------------------



		if par.magnetic == 1: # includes the Lorentz force, applied uniform field along z
			
			
			# Poloidal magnetic field terms (Lorentz force)
			# ------------------------------------------------------------------ A, b_pol, 1curl (hydro, Lorentz)

			col2 = 2*nb*par.N + ( rank*bpp + k )* par.N
		
			# Physics -----------------------------
			lore = 1j*par.m*( -L*Ib + 2*r1D1b + r2D2b )
			tmp = lore*par.Le2
			# -------------------------------------
		
			# bookkeeping
			tmp.eliminate_zeros()
			tmp = tmp.tocoo()
			blk = [tmp.data, tmp.row + row, tmp.col + col2]	
			for q in [0,1,2]:	
				loc_list[q]= np.concatenate( ( loc_list[q], blk[q] ) )


			# Toroidal magnetic terms (Lorentz force)
			# ------------------------------------------------------------------ A, b_tor, 1curl (hydro, Lorentz)
		
			# l-1 terms ---------------------------------------
			if ((l-1 >= ut.m_bot) and (ut.symm1==-1)) or (ut.symm1==1) :
				
				if ut.symm1 == -1 :
					col3a = 3*nb*par.N + ( rank*bpp + k - 1 )* par.N	# left of diag if antisymm
				elif ut.symm1 == 1 :
					col3a = 3*nb*par.N + ( rank*bpp + k )* par.N   	# on the diag if symm
	
				C = np.sqrt((l-par.m)*(l+par.m))*(l**2-1)/(2*l-1)
				
				# Physics ---------------------
				lore = C*( (l-1)*r1Ib - r2D1b )
				tmp = lore*par.Le2
				# -----------------------------
				
				# bookkeeping
				tmp.eliminate_zeros()
				tmp = tmp.tocoo()
				blk = [tmp.data, tmp.row + row, tmp.col + col3a]	
				for q in [0,1,2]:	
					loc_list[q]= np.concatenate( ( loc_list[q], blk[q] ) )
			

			# l+1 terms --------------------------------------------
			if ((l+1 <= ut.lmax_bot-1) and (ut.symm1==1)) or (ut.symm1==-1) :
				
				if ut.symm1 == 1 :
					col3b = 3*nb*par.N + ( rank*bpp + k + 1 )* par.N	# right of diag if symm
				elif ut.symm1 == -1 :
					col3b = 3*nb*par.N + ( rank*bpp + k )* par.N		# on diag if antisymm
					
				C = np.sqrt((l+par.m+1)*(l+1-par.m))*l*(l+2)/(2*l+3)
				
				# Physics ----------------------
				lore = C*( -(l+2)*r1Ib - r2D1b )
				tmp = lore*par.Le2
				# ------------------------------
				
				# bookkeeping
				tmp.eliminate_zeros()
				tmp = tmp.tocoo()
				blk = [tmp.data, tmp.row + row, tmp.col + col3b]
				for q in [0,1,2]:	
					loc_list[q]= np.concatenate( ( loc_list[q], blk[q] ) )
		

	if par.magnetic == 1: # includes the induction equation
		
		# Submatrices here for nocurl and 1curl eqs have only 2 rows empty at the top
		# instead of 4 to make room for the magnetic (insulating) boundary conditions
		# their label ends with 'b' instead of 't'
	
		# ---------------------------------------------------------------------------------------------- A matrix, nocurl induction
		for k,l in enumerate(loc_bot): # here use the l's from loc_bot 
		
			row = 2*nb*par.N + (rank*bpp + k )* par.N
			L = l*(l+1.)
		
		
			# Poloidal velociy terms ( nabla x u x B0 )
			# ------------------------------------------------------------------ A, u_pol, nocurl (induction)
			
			# l-1 terms ---------------------------------------
			if ((l-1 >= ut.m_bot) and (ut.symm1==-1)) or (ut.symm1==1) :
				
				if ut.symm1 == -1 :
					col0a = ( rank*bpp + k - 1 )* par.N	# left of diag if antisymm
				elif ut.symm1 == 1 :
					col0a = ( rank*bpp + k )* par.N   	# on the diag if symm
			
				C = np.sqrt( (l-par.m)*(l+par.m) )*(l**2-1)/(2*l-1)
				
				# Physics ----------------------
				induc = C*( (l-1)*r1Ib - r2D1b )
				tmp = induc
				# ------------------------------
				
				# bookkeeping
				tmp.eliminate_zeros()
				tmp = tmp.tocoo()
				blk = [tmp.data, tmp.row + row, tmp.col + col0a]	
				for q in [0,1,2]:	
					loc_list[q]= np.concatenate( ( loc_list[q], blk[q] ) )
				
		
			# l+1 terms --------------------------------------------
			if ((l+1 <= ut.lmax_bot-1) and (ut.symm1==1)) or (ut.symm1==-1) :
				
				if ut.symm1 == 1 :
					col0b = ( rank*bpp + k + 1 )* par.N	# right of diag if symm
				elif ut.symm1 == -1 :
					col0b = ( rank*bpp + k )* par.N		# on diag if antisymm
			
				C = -np.sqrt( (l+1-par.m)*(l+par.m+1) )*l*(l+2)/(2*l+3)
				
				# Physics ----------------------
				induc = C*( (l+2)*r1Ib + r2D1b )
				tmp = induc
				# ------------------------------
				
				# bookkeeping
				tmp.eliminate_zeros()
				tmp = tmp.tocoo()
				blk = [tmp.data, tmp.row + row, tmp.col + col0b]	
				for q in [0,1,2]:	
					loc_list[q]= np.concatenate( ( loc_list[q], blk[q] ) )
				
		
			# Toroidal velocity terms
			# ------------------------------------------------------------------ A, u_tor, nocurl (induction)
			
			col1 = nb*par.N + (rank*bpp + k )* par.N
			
			# Physics --------
			induc = -1j*par.m*r2Ib
			tmp = induc
			# ----------------
			
			# bookkeeping
			tmp.eliminate_zeros()
			tmp = tmp.tocoo()
			blk = [tmp.data, tmp.row + row, tmp.col + col1]	
			for q in [0,1,2]:	
					loc_list[q]= np.concatenate( ( loc_list[q], blk[q] ) )
					
		
			# Poloidal magnetic field terms (diffusion + iwb term)
			# ------------------------------------------------------------------ A, b_pol, nocurl (induction)
			
			col2 = 2*nb*par.N + (rank*bpp + k )* par.N
			
			# Physics ----------------------
			difus = - L*Ib + 2*r1D1b + r2D2b 
			iwb = L*(1j*ut.wf)*r2Ib
			tmp = iwb - difus*L*par.Em
			# ------------------------------
			
			# bookkeeping
			tmp.eliminate_zeros()
			tmp = tmp.tocoo()
			blk = [tmp.data, tmp.row + row, tmp.col + col2]	
			for q in [0,1,2]:	
					loc_list[q]= np.concatenate( ( loc_list[q], blk[q] ) )
			
			
			# Toroidal magnetic terms (diffusion term + iwb term)
			# ------------------------------------------------------------------ A, b_tor, nocurl (induction)
			# nothing 
		

			# -----------------------------------------------------------
			# include magnetic boundary conditions and update loc_list
			bc_b_list = bc_b_spherical( l, 'nocurl' )
			for q in [0,1,2]:	
				loc_list[q]= np.concatenate( ( loc_list[q], bc_b_list[q] ) )
			# -----------------------------------------------------------



		# --------------------------------------------------------------------------------------- A matrix, 1curl induction
		for k,l in enumerate(loc_top): # use l's from loc_top for 1curl eqs
			
			L = l*(l+1.)
			row = 3*nb*par.N + ( rank*bpp + k )* par.N	
		
		
			# Poloidal velociy terms
			# ------------------------------------------------------------------ A, u_pol, 1curl (induction)
			
			col0 = ( rank*bpp + k )* par.N
			
			# Physics ------------------------------
			induc = 1j*par.m*( -L*Ib + 2*r1D1b + r2D2b )
			tmp = induc
			# --------------------------------------
			
			# bookkeeping
			tmp.eliminate_zeros()
			tmp = tmp.tocoo()
			blk = [tmp.data, tmp.row + row, tmp.col + col0]
			for q in [0,1,2]:	
					loc_list[q]= np.concatenate( ( loc_list[q], blk[q] ) )
				

			# Toroidal velocity terms
			# ------------------------------------------------------------------ A, u_tor, 1curl (induction)
						
			# l-1 terms ---------------------------------------
			if ((l-1 >= ut.m_top) and (ut.symm1==1)) or (ut.symm1==-1) :
				
				if ut.symm1 == 1 :
					col1a = nb*par.N + ( rank*bpp + k - 1 )* par.N # left of diag if symm
				elif ut.symm1 == -1 :
					col1a = nb*par.N + ( rank*bpp + k )* par.N # on the diag if antisymm	
			
				C = np.sqrt( (l-par.m)*(l+par.m) )*(l**2-1)/(2*l-1)
				
				# Physics ----------------------
				induc = C*( (l-1)*r1Ib - r2D1b )
				tmp = induc
				# ------------------------------
				
				# bookkeeping
				tmp.eliminate_zeros()
				tmp = tmp.tocoo()
				blk = [tmp.data, tmp.row + row, tmp.col + col1a]	
				for q in [0,1,2]:	
					loc_list[q]= np.concatenate( ( loc_list[q], blk[q] ) )
					
		
			# l+1 terms --------------------------------------------
			if ((l+1 <= ut.lmax_top-1) and (ut.symm1==-1)) or (ut.symm1==1) :
				
				if ut.symm1 == -1 :
					col1b = nb*par.N + ( rank*bpp + k + 1 )* par.N # right of diag if antisymm
				elif ut.symm1 == 1 :
					col1b = nb*par.N + ( rank*bpp + k )* par.N # on diag if symm
			
				C = -np.sqrt( (l+par.m+1)*(l+1-par.m) )*l*(l+2)/(2*l+3)
				
				# Physics ------------------------
				induc = C*( (l+2)*r1Ib + r2D1b )
				tmp = induc
				# --------------------------------
				
				# bookkeeping
				tmp.eliminate_zeros()
				tmp = tmp.tocoo()
				blk = [tmp.data, tmp.row + row, tmp.col + col1b]
				for q in [0,1,2]:	
					loc_list[q]= np.concatenate( ( loc_list[q], blk[q] ) )
				

			# Poloidal magnetic terms (diffusion + iwb term)
			# ------------------------------------------------------------------ A, b_pol, 1curl (induction)
			# nothing
	
			
			# Toroidal magnetic terms (diffusion + iwb term)
			# ------------------------------------------------------------------ A, b_tor, 1curl (induction)
	
			col3 = 3*nb*par.N + ( rank*bpp + k )* par.N
			
			# Physics ----------------------
			difus = - L*Ib + 2*r1D1b + r2D2b
			iwb  = L*r2Ib*(1j*ut.wf)
			tmp = iwb - difus*L*par.Em
			# ------------------------------
			
			# bookkeeping
			tmp.eliminate_zeros()
			tmp = tmp.tocoo()
			blk = [tmp.data, tmp.row + row, tmp.col + col3]	
			for q in [0,1,2]:	
					loc_list[q]= np.concatenate( ( loc_list[q], blk[q] ) )
	
			
			# -----------------------------------------------------------
			# include magnetic boundary conditions and update loc_list
			bc_b_list = bc_b_spherical( l, '1curl' )
			for q in [0,1,2]:	
				loc_list[q]= np.concatenate( ( loc_list[q], bc_b_list[q] ) )
			# -----------------------------------------------------------
			
	
	
	# -------------------------------------------------------------------------- A matrix assembly
	# We use comm.allgather here to figure out the right size 
	# for the local variables bdat, brow and bcol.
	# They all need to be the same size for comm.Gather to work with them.
	 
	s = np.shape(loc_list[0])[0]
	alls = comm.allgather(s)
	length = max(alls)
	
	bdat = np.zeros(length,dtype=complex)
	brow = -np.ones(length,dtype=np.int64)
	bcol = -np.ones(length,dtype=np.int64)

	bdat[:s] = loc_list[0]
	brow[:s] = loc_list[1]
	bcol[:s] = loc_list[2]
	
	# fdat, frow and fcol are variables that will store the full A matrix
	# a Gather command will send all local data (bdat, brow, bcol)
	# from each rank to the rank 0 process.
	
	fdat = None
	frow = None
	fcol = None
	
	# We need to initialize explicitely the variables in rank 0:
	if rank == 0:
		fdat = np.zeros(length*sizas,dtype=complex)
		frow = np.zeros(length*sizas,dtype=np.int64)
		fcol = np.zeros(length*sizas,dtype=np.int64)
		
	
	# and finally gather all local data to (fdat,frow,fcol)
	
	comm.Gather([bdat,MPI.DOUBLE_COMPLEX],[fdat,MPI.DOUBLE_COMPLEX],root=0)
	comm.Gather(brow,frow,root=0)
	comm.Gather(bcol,fcol,root=0)

	if rank == 0:
		
		ix = np.where(frow >= 0)
		A = ss.csr_matrix((fdat[ix], (frow[ix], fcol[ix])), shape=(ut.sizmat,ut.sizmat), dtype=complex)
		if par.forcing == 0: 
			A = A/Bnorm
	
		toc = timer()
		print('Matrix A assembled in', toc-tic, 'seconds')
		tic = timer()

		np.savez('A.npz', data=A.data, indices=A.indices, indptr=A.indptr, shape=A.shape)
		toc = timer()
		print('Matrix A written to disk in', toc-tic, 'seconds')
	
	comm.Barrier()
	

	# Free memory space
	wig.wig_temp_free()
	wig.wig_table_free()	

	# -------------------------------------------------------------------------- done!
	return 0
	
	

def bc_u_spherical(l,loc):
	'''
	Spherical boundary conditions for the velocity field,
	either stress-free or no-slip.
	'''		
	if   loc == '2curl': # 
	
		out = ss.dok_matrix((4,par.N),dtype=complex)

		if   par.bci == 0: # stress-free icb
			out[ 0,:] = bv.Ta[:,0] # P  =0
			out[ 1,:] = bv.Ta[:,2] # P''=0
		
		elif par.bci == 1: # no-slip icb
			out[ 0,:] = bv.Ta[:,0] # P  =0
			out[ 1,:] = bv.Ta[:,1] # P' =0
			
		if   par.bco == 0: # stress-free cmb	
			out[ 2,:] = bv.Tb[:,0] # P  =0
			out[ 3,:] = bv.Tb[:,2] # P''=0
		
		elif par.bco == 1: # no-slip cmb
			out[ 2,:] = bv.Tb[:,0] # P  =0
			out[ 3,:] = bv.Tb[:,1] # P' =0
		
		row0 = int(par.N*(l-ut.m_top)/2)
		col0 = int(par.N*(l-ut.m_top)/2)
				
	elif loc == '1curl': # 
		
		out = ss.dok_matrix((2,par.N),dtype=complex)
		
		if   par.bci == 0: # stress-free icb
			out[ 0,:] = bv.Ta[:,1]-bv.Ta[:,0]/par.ricb	# T'-(T/r)=0

		elif par.bci == 1: # no-slip icb
			out[ 0,:] = bv.Ta[:,0]	# T=0
			
		if   par.bco == 0: # stress-free cmb
			out[ 1,:] = bv.Tb[:,1]-bv.Tb[:,0]/ut.rcmb	# T'-(T/r)=0	
						
		elif par.bco == 1: # no-slip cmb
			out[ 1,:] = bv.Tb[:,0]	# T=0

		row0 = ut.n + int( par.N*(l-ut.m_bot)/2 )
		col0 = ut.n + int( par.N*(l-ut.m_bot)/2 ) 	

	out = out.tocoo()	
	out2 = [out.data, out.row + row0, out.col + col0]
					
	return out2




def bc_b_spherical(l,loc):
	'''
	Insulating boundary conditions for the magnetic field
	'''
	if loc == 'nocurl': # use loc_bot l's here (if external magnetic field is antisymm)

		out = ss.dok_matrix((2, par.N),dtype=complex)
		
		out[0,:] = l * bv.P0_icb - par.ricb * bv.P1_icb  # icb
		out[1,:] = (l+1) * bv.P0_cmb + bv.P1_cmb   # cmb
		
		row0 = 2*ut.n + int( par.N * ( l - ut.m_bot)/2 )	# starting row
		col0 = 2*ut.n + int( par.N * ( l - ut.m_bot)/2 )	# starting col
		
	elif loc == '1curl': # use loc_top l's here (if external magnetic field is antisymm)

		out = ss.dok_matrix((2, par.N),dtype=complex)
		
		out[0,:] = bv.T0_icb  # icb
		out[1,:] = bv.T0_cmb  # cmb
		
		row0 = 3*ut.n + int( par.N*(l - ut.m_top)/2 )	# starting row
		col0 = 3*ut.n + int( par.N*(l - ut.m_top)/2 )   # starting col
	
	out = out.tocoo()	
	out2 = [out.data, out.row + row0, out.col + col0]

	return out2





def Clam(L,l,m,n, lamb0):
	# 
	tmp1 = wig.wig3jj( 2* l , 2* lamb0 , 2* L , 2* m, 0 , 2*(-m) )
	tmp2 = wig.wig3jj( 2* l , 2* lamb0 , 2* L , 2* n, 0 , 2*(-n) )
	out = (-1)**(m+n)*(2*L+1.)*tmp1*tmp2
	
	return out



	
if __name__ == "__main__": 
	sys.exit(main())
